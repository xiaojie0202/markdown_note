# 生成器
    通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。
# 生成器前戏-列表推导式
>- 列表生成式
```python
# 需求： 求0-1000的中的奇数
a =  [i for i in range(1000) if i%2 != 0]
```
# 生成器主题-列表推导式变生成器
```
# 分析： 列表推导式当生成的数据过多的时候会特别消耗内存，对于此方法，python中加入了生成器的概念，当取值的时候才会生成，只要把列表推导式的[]换成()即可
a =  (i for i in range(1000) if i%2 != 0)

In [17]: a # a是一个生成器对象
Out[17]: <generator object <genexpr> at 0x000001A1E8829D58>

In [19]: next(a) # 可以利用next方法对a进行取值
Out[19]: 1

In [21]: a.__next__() # 也可以调用生成器内部的的__next__方法进行取值
Out[21]: 3

# for循环其实就是i调用可迭代对象的__iter__()方法
In [23]: for i in a: 
    ...:     print(i)
    ...:
5
7
9
……


In [32]: for i in b.__iter__():
    ...:     print(i)
    ...:
1
2
3
```
# 生成器进阶-函数式成器
    在上述生成器中，如果我想实现需要做一堆运算的数据，那么上述的元祖生成器就不能实现了，对此python中yield关键字可以把一个函数变成生成器、
    
```
# 需求：斐波那契数列

def create_number():
    a, b = 0, 1
    for i in range(10):
        yield b # 当程序执行到此，会卡住，除非调用next或者__next__方法，再或者send()方法才会继续执行
        a, b = b, a+b


In [35]: create_number() # 函数执行会返回一个生成器对象
Out[35]: <generator object create_number at 0x000001A1E88C2728>

In [36]: for i in create_number():
    ...:     print(i)
    ...:
1
1
2
3
5
8
13
21
34
55
```
# 生成器的郁闷-send方法
    在函数生成器中，第一次创建生成器的时候，直接使用send方法传递一个参数或者不传递参数会崩掉，此时又想直接执行send方法应该send(None)